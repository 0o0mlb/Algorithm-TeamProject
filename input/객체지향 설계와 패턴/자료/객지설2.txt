위 코드는 비교적 간단하지만 다음의 문제를 포함하고 있습니다.

서로 다른 계산 정책들이 한 코드에 섞여 있어, 정책이 추가될수록 코드 분석을 어렵게 만듭니다.
가격 정책이 추가될 때마다 calculate 메서드를 수정하는 것이 점점 어려워집니다. 예를 들어 마지막 손님 50% 할인과 같은 새로운 가격 정책이 추가될 경우, calculate 메서드에 마지막 손님을 구분하기 위한 lastGuest 파라미터가 추가되고, if 블록이 하나 더 추가되어야 합니다.
이런 문제를 해결하기 위한 방법 중의 하나는 아래 그림처럼 가격 할인 정책을 별도 객체로 분리하는 것입니다.

자료
위 그림에서 DiscountStrategy 인터페이스는 상품의 할인 금액 계산을 추상화하였고, 각 콘크리트 클래스는 상황에 맞는 할인 계산 알고리즘을 제공합니다. Calculator 클래스는 가격 합산 게산의 책임을 집니다. 여기서 가격 할인 알고리즘을 추상화하고 있는 DiscountStrategy을 전략이라고 부르고 가격 계산 기능 자체의 책임을 갖고 있는 Caculator를 콘텍스트라고 부르는데, 이렇게 특정 콘텍스트에서 알고리즘을 별도로 분리하는 설계 방법이 전략 패턴입니다.

객체설계에서 콘텍스트는 사용할 전략을 직접 선택하지 않습니다. 대신 콘텍스트의 클라이언트가 콘텍스트에 사용햘 전략을 전달 해줍니다. 즉, DI(의존성 주입)를 이용해서 콘텍스트에 전략을 전달해 줍니다. 그리고 전략이 어떤 메서드를 제공할 지의 여부는 콘텍스트가 전략을 어떤 식으로 사용하느냐에 따라 달라집니다.

앞서 위에 그림에서 보여주는 금액 할인 정책을 DiscountStrategy로 분리한 경우, 아래 코드처럼 Calculator를 구현할 수 있을 것입니다.