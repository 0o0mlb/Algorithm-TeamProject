EncryptionOut 클래스의 write() 메서드는 파일에 쓸 데이터를 암호화 한 뒤에, doDelegate() 메서드를 이용해서 암호화된 데이터를 delegate 객체에 전달합니다. BufferedOut 클래스와 ZipOut 클래스도 비슷한 방식으로 구현합니다.

이제 파일에 데이터를 암호화해서 쓰는 기능이 필요한 곳의 코드를 만들어 봅시다. 이 코드는 다음과 같이 FileOut 객체를 이용해서 EncryptionOut 객체를 생성한 뒤에, EncryptionOut 객체의 writ() 메서드를 실행합니다.

FileOut delegate = new FileOutImpl();
FileOut fileOut = new EncryptionOut(delegate);
fileOut.write(data);
EncryptionOut의 write() 메서드를 실행하면 EncryptionOut의 write() 메서드에서 데이터를 암호화하고, FileOutImpl 객체의 write() 메서드에 암호화 된 데이터를 전달하게 됩니다. 여기서 EncryptionOut 객체는 FileOutImpl 객체가 제공하는 파일 쓰기 기능에 암호화 기능을 추가해 주는 역할을 수행하게 되며, 기존 기능에 새로운 기능을 추가해 준다는 의미에서 EncrpytionOut 객체를 데코레이터라고 부릅니다.
객체지향 설계와 패턴
데코레이터 패턴의 장점은 데코레이터를 조합하는 방식으로 기능을 확장할 수 있다는 데에 있습니다.
자료
FileOut delegate = new FileOutImpl();
FileOut fileOut = new EncryptionOut(new ZipOut(delegate));
fileOut.wirte(data);
기능 적용 순서의 변경도 쉽습니다. 아래 코드처럼 데코레이터 생성 순서를 변경해 주기만 하면 됩니다.

// 버퍼 -> 암호화 -> 압축 -> 파일 쓰기
FileOut fileOut = new BufferedOut(new EncryptionOut(new ZipOut(delegate)));

// 암호화 -> 압축 -> 버퍼 -> 파일 쓰기
FileOut fileOut = new EncryptionOut(new ZipOut(new BufferedOut(delegate)));
데코레이터 패턴을 사용하면 각 확장 기능들의 구현이 별도의 클래스로 분리되기 때문에, 각 확장 기능 및 원래 기능을 서로 영향 없이 변경할 수 있도록 만들어 줍니다. FileOutImpl 클래스의 구현을 변경하더라도 EncryptionOut 클래스가 내부 암호화 알고리즘을 변경하더라도 다른 데코레이터나 FileOutImpl 클래스는 영향을 받지 않습니다. 즉, 데코레이터 패턴은 단일 책임 원칙을 지킬수 있도록 만들어 줍니다.

데코레이터 패턴은 전략 패턴/템플릿 메서드 패턴/상태 패턴과 함께 매우 흔하게 사용되는 패턴입니다. 스프링 프레임워크의 경우 트랜잭션 처리를 위해 데코레이터 패턴을 사용합니다. 스프링 프레임워크에서 트랜잭션 관련 설정을 추가하면, 아래 그림과 같이 트랜잭션 기능이 추가된 데코레이터 객체를 런타임에 생성합니다.



스프링 프레임워크는 데코레이터를 이용해서 트랜잭션을 처리합니다.

데코레이터 패턴을 적용할 때 고려할 점
데코레이터 패턴을 구현할 때 고려할 점은 데코레이터 대상이 되는 타입의 기능 개수에 대한 것입니다. 앞서 예제에서 데코레이터 대상이 되는 FileOut 타입은 write() 메서드가 한 개만 정의되어 있어 데코레이터 구현이 비교적 간단하지만, 정의되어 있는 메서드가 증가하게 되면 그만큼 데코레이터의 구현도 복잡해집니다.

데코레이터 구현에서 고려해야 할 또 다른 사항은 데코레이터 객체가 비정상적으로 동작할 때 어떻게 처리할 것이냐에 대한 것입니다.

예를 들어, 게시글 작성 이후 생성된 게시글 데이터를 외부 메시지 서버에 전송해 주는 기능을 별도의 데코레이터로 구현했다고 합시다. 이 경우 런타임의 객체 간 메시지 흐름은 아래와 같습니다.



외부의 메시지 서버에 장애가 발생하면, 위 그림의 실행 흐름에서 6번 과정에 문제가 발생하게 됩니다. 하지만, 1~5번까지의 과정은 정상적으로 실행이되어 트랜잭션이 커밋되었기 때문에 DB에는 새로운 데이터가 정상적으로 추가됩니다. 이 경우 6번 과정의 문제가 발생했다고 해서 클라이언트에 익셉션을 발생시키는 것은 올바른지 고민해 봐야합니다. 왜냐하면 클라이언트가 요구하는 기능인 게시글 등록 자체는 정상적으로 실행되었기 때문입니다.

이런 경우 메시지 전송 데코레이터는 외부 메시지 서버에 데이터 전송에 실패하더라도 익셉션을 발생시키지는 대신 실패 로그를 남기는 방법을 선택할 수 있습니다. 이렇게 함으로써 외부 메시지 서버 연동에 실패하더라도 클라이언트는 에러 결과가 아닌 정상 결과를 볼 수 있으며, 향후에 실패 로그를 이용해서 데이터 재전송 같은 사후 처리를 할 수 있게 됩니다.

데코레이터의 단점은 사용자 입장에서 데코레이터 객체와 실제 구현 객체의 구분이 되지 않기 때문에 코드만으로는 기능이 어떻게 동작하는지 이해하기가 어렵습니다.

예를 들어, 아래 코드에서 writeTo() 메서드는 파라미터로 전달 받은 FileOut 객체를 사용하는데, writeTo() 메서드는 이 FileOut 객체가 단순히 파일에 쓰기만 하는지 아니면 압추을 하는지 등의 여부를 알 수 없습니다. 실제로 FileOut 객체가 어떻게 동작하는지 알려면 런타임에 생성된 객체의 구조를 이해해야 합니다.

public class ImageSource {

    public void writeTo(FileOut out) {
        out.write(imageData);
    }
}
6. 프록시(proxy) 패턴
제품 목록을 보여주는 GUI 프로그램은 아래 그림처럼 목록 중 일부를 화면에 보여주고, 스크롤을 할 때 나머지 목록을 화면에 표시할 수 있습니다.



제품 목록을 구성할 때 관련된 모든 이미지를 로딩하도록 구현할 수 있는데, 이 경우 블필요하게 메모리를 사용하는 문제가 발생할 수 있습니다.

예를 들어, 목록 하단에 위치한 이미지는 실제로 스크롤을 하기 전까지는 화면에 보이지 않음에도 불구하고 목록을 구성할 때 메모리에 이미지 정보를 로딩하게 됩니다. 특히 이미지를 로컬 파일 시스템이 아닌 웹에서 읽어 온다면 이미지 로딩으로 인해 제품 목록을 보여주기 까지 대기 시간이 길어지게 됩니다.

불필요한 이미지 로딩에 따른 메모리 낭비와 이미지 로딩에 따른 화면 출력 대기 시간이 길어지는 문제를 해결하는 방법은 이미지가 실제로 화면에 보여질 때 이미지 데이터를 로딩하는 것입니다. 이미지가 필요할 때 이미지 데이터를 로딩하는 기능을 추가하는 가장 쉬운 방법은 필요 시점에 Image 클래스를 이용해서 이미지를 로딩하는 DynamicLoadingImage 클래스를 추가하고, 아래 그림과 같이 목록을 보여주는 클래스에서 Image 클래스 대신 DynamicLoadingImage를 사용하게 만드는 것입니다.



하지만, 위 그림과 같이 구현하게 되면, 이미지 로딩 방식을 변경해야 할 때 ListUI 코드를 변경해야 하는 문제가 발생합니다. 예를 들어, 화면에 보여줄 목록의 개수가 5개 미만이면 바로 로딩하고 5개 이상이면 동적으로 로딩하도록 구현해야 할 때 ListUI 코드는 Image 클래스와 DynamicLoadingImage 클래스를 구분하는 조건문을 갖게 될 것입니다.

이런 상황에서 ListUI 변경 없이 이미지 로딩 방식을 교체할 수 있도록 해주는 패턴이 프록시 패턴입니다. 프록시 패턴은 실제 객체를 대신하는 프록시 객체를 사용해서 실제 객체의 생성이나 접근 등을 제어할 수 있도록 해 주는 패턴으로서, 구조는 아래 그림과 같습니다.

객체설계


위 그림에서 Image 인터페이스는 이미지를 표현하며 ListUI는 Image 타입을 이용해서 화면에 이미지를 표시합니다. RealImage 클래스는 실제로 이미지 데이터를 로딩해서 메모리에 보관하는 콘크리트 클래스입니다. 여기서 중요한 건 ProxyImage 클래스입니다.

PrxoyImage 클래스가 프록시 패턴에서 프록시 역할을 하는데, ProxyImage 클래스는 아래 코드처럼 구현됩니다.