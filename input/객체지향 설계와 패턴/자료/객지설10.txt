public class SelectableState implements State {
    // 콘텍스트가 상태를 변경하므로, 상태 객체는 자신이 할 작업만 처리합니다.
    @Override
    public void select(int productId, VendingMachine vm) {
        vm.provideProduct(productId);
        vm.decreaseCoin();
    }
}
콘텍스트의 상태 변경을 누가 할지는 주어진 상황에 맞게 정해주어야 합니다. 먼저 콘텍스트에서 상태를 변경하는 방식은 비교적 상태 개수가 적고 상태 변경 규칙이 거의 바뀌지 않는 경우에 유리합니다. 왜냐하면 상태 종류가 지속적으로 변경되거나 상태 변경 규칙이 자주 바뀔 경우 콘텍스트의 상태 변경 처리가 복잡해질 가능성이 높기 때문입니다. 상태 변경 처리 코드가 복잡해질수록 상태 변경의 유연함이 떨어집니다.
자료
// 객체지향 설계와 패턴

반면에 상태 객체에서 콘텍스트의 상태를 변경할 경우, 콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경 규칙을 바꿀 수 있게 됩니다. 하지만 상태 변경 규칙이 여러 클래스에서 분산되어 있기 때문에, 상태 구현 클래스가 많아질수록 상태 변경 규칙을 파악하기가 어려워지는 단점이 있습니다. 또한, 한 상태 클레스에서 다른 상태 클래스에 대한 의존도 발생합니다.

두 방식은 명확하게 서로 상반되는 장단점을 갖고 있기 때문에, 상태 패턴을 적용할 때에는 주어진 상황에 알맞은 방식을 선택해야 합니다.

5. 데코레이터(Decorator) 패턴
상속은 기능을 확장하는 방법을 제공합니다. 예를 들어, 데이터를 파일에 출력하는 기능을 제공하는 FileOut 클래스가 있을 때, FileOut 클래스에 버퍼 기능을 추가하거나 압축 기능을 추가하려면 상속을 받아서 기능을 확장해서 구현할 수 있을 것입니다.

상속을 이용한 기능 확장 방법이 쉽긴 하지만, 다양한 조합의 기능 확장이 요구될 때 클래스가 불필요하게 증가하는 문제가 발생합니다. 버퍼 기능과 압축 기능을 함께 제공해야 한다거나, 압축한 뒤 암호화 기능을 제공해야 한다거나, 또는 버퍼 기능과 암호화 기능을 함께 제공해야 한다면, 클래스가 증가하고 계층 구조가 복잡해집니다.

이런 경우 사용할 수 있는 패턴이 데코레이터 패턴입니다. 데코레이터 패턴은 상속이 아닌 위임을 하는 방식으로 기능을 확장해 나갑니다. 위 예제에 데코레이터 패턴을 적용하면 아래 그림과 같이 바뀝니다.
과제


그림에서 FileOut 인터페이스는 파일 출력 기능을 정의하고 있고, 실제 파일 출력 기능은 FileOutImpl 클래스가 구현하고 있습니다. 여기서 중요한 점은 기능 확장을 위해 FileOutImpl 클래스를 상속받지 않고, Decorator라고 불리는 별도의 추상 클래스를 만들었다는 점입니다.

Decorator 클래스는 모든 데코레이트를 위한 기반 기능을 제공하는 추상 클래스로서 코드는 아래와 같습니다. 이 클래스의 doDelegate() 메서드는 생성자를 통해서 전달받은 FileOut 객체에 쓰기 기능을 위임합니다.

public abstract class Decorator implements FileOut {

    private FileOut delegate; // 위임 대상

    public Decorator(FileOut delegate) {
        this.delegate = delegate;
    }

    protected void doDelegate(byte[] data) {
        delegate.write(data); // delegate 쓰기 위임
    }
}
BufferdOut 클래스, EncryptionOut 클래스, ZipOut 클래스는 모두 데코레이터 클래스로서 Decorator 클래스를 상속받고 있습니다. 이들 클래스는 자신의 기능을 수행한 뒤에 상위 클래스의 doDelegate() 메서드를 이용해서 파일 쓰기를 위임하도록 구현합니다. 예를 들어, EncryptionOut 클래스는 아래와 같이 구현할 수 있습니다.