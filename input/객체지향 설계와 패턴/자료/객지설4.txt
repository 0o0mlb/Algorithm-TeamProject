위 코드를 보면 Calculator를 사용하는 코드에서 FirstGuestDiscountStrategy 클래스의 객체를 생성하는 것을 알 수 있습니다. 이는 콘텍스트를 사용하는 클라이언트가 아래 그림처럼 전략의 상세 구현에 대한 의존이 발생한다는 것을 뜻합니다.



콘텍스트의 클라이언트가 전략 인터페이스가 아닌 상세 구현을 안다는 것이 문제처럼 보일 수 있으나, 이 경우에는 전략의 콘크리트 클래스와 클라이언트의 코드가 쌍을 이루기 때문에 유지 보수 문제가 발생할 가능성이 줄어듭니다.

객체지향 설계와 패턴 실험 자료

예를 들어, 덜 신선한 과일 할인 정책을 추가하려면 클라이언트에 덜 신선한 과일 할인정책 적용 버튼을 처리하는 코드가 생기고 이 코드에서 NonFreshDiscountStrategy 객체를 생성해 주게 됩니다. 또한 기능이 제거될 때에도 함께 제거됩니다. 따라서 클라이언트의 버튼 처리 코드에서 전략 객체를 직접 생성하는 것은 오히려 코드 이해를 높이고 코드 응집을 높여주는 효과를 갖습니다.

전략 패턴을 적용할 때 얻을 수 있는 이점은 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다는 점입니다. 앞에서 본 예제에서 마지막 손님 대폭 할인 정책을 추가하는 경우, 계산을 제공하는 Calculator 클래스의 코드는 변경되지 않습니다. 단지 새로운 할인 정책을 구현한 LastGuestDiscountStrategy 클래스를 추가하고, 마지막 손님 대폭 할인 버튼을 클릭을 처리하는 코드에서 LastGuestDiscountStrategy의 객체를 생성해 주기만 하면 됩니다.